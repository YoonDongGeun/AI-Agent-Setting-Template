# 문서 작성 AI 지침(토스 테크니컬 라이팅 참조)

## 1. 문서 유형 정하기

문서는 다음과 같이 4종류로 구분하여 알맞는 종류로 작성한다.

| 문서 유형          | 독자의 목적                                                  | 예시                                                         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **학습 중심 문서** | 새로운 기술이나 도구를 처음 접해서 간단히 어떤 흐름인지 알고 싶을 때 사용해요. 초보자가 쉽게 시작할 수 있는 튜토리얼이나 사전 준비도 여기에 속해요. | [use-funnel 시작하기](https://use-funnel.slash.page/ko/docs/get-started) / [Kotlin 시작하기](https://kotlinlang.org/docs/getting-started.html) / [MDN Web Docs - HTML 기본](https://developer.mozilla.org/ko/docs/Learn_web_development/Getting_started/Your_first_website/Creating_the_content) / [토스페이먼츠 개발자센터 - 결제 연동하기](https://docs.tosspayments.com/guides/v2/payment-widget/integration) |
| **문제 해결 문서** | 배경 지식이 있는 상태에서 기술이나 도구를 사용하다 생기는 특정한 문제를 해결하고 싶을 때 사용해요. | [Stripe Docs - Collect physical addresses](https://docs.stripe.com/payments/collect-addresses) / [use-funnel - 퍼널 안에 퍼널 만들기](https://use-funnel.slash.page/ko/docs/sub-funnel) |
| **참조 문서**      | 이미 기본적인 작동 방법을 알고 있는 상태에서 특정 기능이나 API 사용법을 확인해서 적용하고 싶을 때 사용해요. 특정 API 함수의 매개변수, 반환 값, 예제 코드 등을 확인하는 거에요. | [es-toolkit 레퍼런스](https://es-toolkit.slash.page/ko/reference/array/at.html) / [DevDocs JavaScript reference](https://devdocs.io/javascript/) / [MDN Web Docs - Reference](https://developer.mozilla.org/ko/docs/Web) |
| **설명 문서**      | 개념, 원리, 배경 지식을 깊이 이해하고 싶을 때 사용해요. 예를 들어, 왜 이런 기술이 등장했는지, 어떤 문제를 해결하는지 등을 자세히 알고 싶을 때 사용해요. | [MDN Web Docs - 웹의 동작 방식](https://developer.mozilla.org/ko/docs/Learn_web_development/Getting_started/Web_standards/How_the_web_works) |

## 2. 문서 유형에 맞는 글쓰기 방법

| 문서 유형          | 글쓰기 방법                                                  | 예시                                                         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **학습 중심 문서** | 학습을 위한 문서는 독자가 새로운 기술이나 도구를 배울 수 있도록 돕는 문서예요. 이 문서를 읽으면 읽는 사람이 무엇을 할 수 있는지에 대한 명확한 상을 제시할 수 있어야 해요.<br/>1. 처음부터 끝까지 막힘없이 진행할 수 있어야 해요<br/>독자가 따라하다가 막히거나 오류가 나면 안돼요. 마지막 단계까지 문제 없이 따라할 수 있도록 안정적인 학습 환경을 만들어 주세요.<br/>모든 예제 코드는 실제로 실행해보고 검증했으며, 필요한 준비 사항도 꼼꼼히 안내해야 해요.<br/>2. 단계별로 설명해요<br/>독자가 차근차근 진행할 수 있도록 구조를 만들어요.<br/>예제도 간단한 것부터 점진적으로 난이도를 올리는 것이 좋습니다.<br/>3. 실행 가능한 코드 예제를 포함해요<br/>단순히 개념만 설명하는 것이 아니라, 실제 실행 가능한 예제 코드를 포함하세요. 예제는 핵심 기능을 잘 드러내야 하고, 독자가 직접 실행해보며 학습할 수 있도록 해야 합니다.<br/>학습 문서에 실행할 수 있는 예제가 있는지 여부는 문서 경험을 향상시키는 주요 요소예요. 실제로 실행할 수 있는 코드가 있으면 코드 사용법에 대한 이해를 직관적으로 할 수 있고 바로 프로젝트에 가져다 쓰기도 편리하기 때문이에요. | # React 시작하기  <br/><br/>React는 컴포넌트 기반으로 UI를 만들 수 있는 라이브러리예요. 여기서는 가장 기본적인 React 프로젝트를 실행해보고 동작 방식을 이해해요.<br/><br/>## React 실행하기<br/><br/>### 1️. 프로젝트 만들기<br/><br/>npx create-react-app my-app<br/>cd my-app<br/>npm start<br/><br/>개발 서버가 실행된 후, 브라우저에서 `http://localhost:3000`을 열어 React 기본 화면을 확인하세요.<br/><br/>## React에서 화면을 만드는 방법<br/><br/>React에서는 컴포넌트라는 개념을 사용해서 화면을 구성해요. 컴포넌트는 UI의 가장 작은 단위예요.<br/><br/>### 기본 컴포넌트 만들기<br/><br/>`src/App.js` 파일을 열고 내용을 아래처럼 바꿔보세요.<br/><br/>function App() {<br/>  return <h1>안녕하세요! React를 시작해 봅시다.</h1>;<br/>}<br/><br/>export default App;<br/><br/>파일을 저장한 후, 브라우저를 새로고침하면 React 기본 화면 대신 "안녕하세요! React를 시작해 봅시다."라는 문구가 표시됩니다.<br/><br/>## 직접 컴포넌트 만들기<br/><br/>1. `src` 폴더 안에 `Welcome.js` 파일을 생성하세요.<br/>2. 다음 코드를 입력하고 저장하세요.<br/><br/>function Welcome({ name }) {<br/>  return <h2>안녕하세요, {name}님!</h2>;<br/>}<br/><br/>export default Welcome;<br/><br/>이제 `App.js`에서 새로운 `Welcome` 컴포넌트를 추가해보세요.<br/><br/>import Welcome from "./Welcome";<br/><br/>function App() {<br/>  return (<br/>    <div><br/>      <h1>React 학습을 시작해봅시다!</h1><br/>      <Welcome name="주연" /><br/>    </div><br/>  );<br/>}<br/><br/>export default App; |
| **문제 해결 문서** | 문제 해결을 위한 문서는 독자가 직면한 문제를 빠르고 효과적으로 해결할 수 있도록 돕는 문서예요.<br/><br/>그래서 이런 문서에서 가장 중요한 것은 이 문서를 보면 독자가 지금 겪고 있는 문제를 해결할 수 있는지 여부예요. 따라서 문제의 원인과 해결 방법을 논리적으로 제공하고, 바로 적용할 수 있는 해결책과 실용적인 예시를 제공해야 해요.<br/>1. 명확한 문제 상황을 정의해요<br/>문제가 발생한 원인과 그로 인해 나타난 현상을 구분해서 설명하세요.에러 메시지, 로그 예시를 포함하면 읽는 사람이 더 쉽게 문제를 이해할 수 있어요.<br/>2. 바로 적용할 수 있는 해결 방법을 제공해요<br/>해결 방법은 명확하고 바로 적용할 수 있어야 해요.<br/>코드 예제, 명령어, 설정 방법을 포함하세요.<br/>해결책이 어떤 원리로 문제를 해결하는지도 언급하면 좋아요.<br/>3. 환경별 차이를 고려해요<br/>같은 문제가 다른 환경이나 설정에서 어떻게 나타날 수 있는지도 다뤄요. 예를 들어, OS나 라이브러리 버전에 따른 차이를 설명해 주세요.. | # React에서 자동 재시도 기능 통합 가이드<br/><br/>자동 재시도 로직을 React 컴포넌트에 통합하여 API 요청 실패 시 자동으로 재시도하는 기능을 구현하는 방법을 알려드려요.<br/><br/>이 기능으로 네트워크 불안정 상황에서도 안정적인 데이터 요청을 보장하여 사용자 경험을 개선할 수 있어요.<br/><br/>## UI 구현하기<br/><br/>다음 예제는 자동 재시도 로직을 활용해 API 데이터를 불러오고, 로딩 상태와 오류 처리를 포함한 UI를 구현하는 코드입니다.<br/><br/>```jsx<br/>import { useEffect, useState } from "react";<br/><br/>function App() {<br/>  const [data, setData] = useState(null);<br/>  const [error, setError] = useState(null);<br/>  const [loading, setLoading] = useState(true);<br/><br/>  useEffect(() => {<br/>    fetchWithRetry("https://jsonplaceholder.typicode.com/todos/1", {}, 3, 1000)<br/>      .then(json => {<br/>        setData(json);<br/>        setLoading(false);<br/>      })<br/>      .catch(err => {<br/>        setError(err.message);<br/>        setLoading(false);<br/>      });<br/>  }, []);<br/><br/>  return (<br/>    <div><br/>      {loading ? (<br/>        <p>데이터 로딩 중...</p><br/>      ) : error ? (<br/>        <p style={{ color: "red" }}>{error}</p><br/>      ) : (<br/>        <div><br/>          <h2>API 데이터</h2><br/>          <pre>{JSON.stringify(data, null, 2)}</pre><br/>        </div><br/>      )}<br/>    </div><br/>  );<br/>}<br/><br/>export default App;<br/>``` |
| **참조 문서**      | 참조 문서는 독자가 특정 기술, 도구, 또는 시스템에 대한 정확하고 완전한 정보를 빠르게 찾을 수 있도록 설계된 문서예요. 핵심은 정확성, 완전성, 검색 용이성이며, 독자가 필요할 때 즉시 원하는 정보를 찾아 적용할 수 있어야 해요.<br/><br/>또 함수, 매개변수, 반환값, 사용 예제 같은 구성을 정하고 일관되게 작성해야 해요.<br/><br/>1. 정확성과 완전성이 중요해요<br/>문서에 포함된 모든 정보는 정확해야 하고, 누락된 부분이 없어야 해요. 기술적 오류나 모호한 설명이 없어야 하며, 항상 최신 상태여야 해요.<br/><br/>2. 일관된 구조로 작성해요<br/>일관된 포맷과 구조로 가독성을 높여야 해요. API 문서라면 함수 이름 → 매개변수 → 반환값 → 예제 코드 순과 같은 표준화된 구조를 만들어요.<br/><br/>3. 검색과 탐색이 쉬워요<br/>독자가 필요한 정보를 빠르게 찾을 수 있도록 문서를 체계적으로 구성해야 해요. 목차, 키워드 검색, 앵커 링크 등을 활용해서 정보를 쉽게 탐색할 수 있도록 해야 해요.<br/><br/>4. 예제 코드를 제공해요<br/>명확한 설명과 함께 예제 코드를 함께 제공해야 해요. 예제 코드로 특정 함수나 API를 어떻게 사용하는지 직관적으로 알 수 있어요. | # `fetch` API<br/><br/>`fetch` 함수는 네트워크 리소스를 요청하고 응답을 처리하는 API예요. 비동기적으로 동작하고, `Promise<Response>` 객체를 반환해요. `fetch` 함수를 활용하면 클라이언트와 서버 간 데이터를 쉽게 주고받을 수 있어, REST API와 같은 서비스와의 통신을 효율적으로 처리할 수 있어요.<br/>`XMLHttpRequest`보다 간결한 문법을 제공하고, `async/await`와 함께 사용하면 가독성이 뛰어나다는 장점도 있어요.<br/><br/>## 시그니처<br/><br/>```typescript<br/>fetch(input: RequestInfo, init?: RequestInit): Promise<Response><br/>```<br/><br/>## 매개변수<br/><br/>- `input` (필수): 요청할 URL 또는 `Request` 객체예요.<br/>- `init` (선택): 요청의 옵션을 담은 객체예요.<br/>  - `method`: HTTP 요청 방식 (GET, POST, PUT, DELETE 등)<br/>  - `headers`: 요청에 포함할 헤더 정보 (예: { 'Content-Type': 'application/json' })<br/>  - `body`: 요청 본문 (예: JSON.stringify({ name: 'John' }))<br/>  - `mode`: 요청 모드 (cors, no-cors, same-origin)<br/>  - `credentials`: 쿠키 포함 여부 (omit, same-origin, include)<br/>  - `cache`: 캐시 정책 (default, no-store, reload, force-cache 등)<br/>  - `redirect`: 리디렉션 처리 방식 (follow, error, manual)<br/><br/>## 반환값<br/><br/>`fetch`는 `Promise<Response>` 객체를 반환해요.<br/><br/>  - `ok`: 응답이 성공(200~299)했는지 여부 (true / false)<br/>  - `status`: HTTP 상태 코드 (200, 404, 500 등)<br/>  - `headers`: 응답 헤더 (Headers 객체)<br/>  - `json`(): 응답을 JSON으로 변환 (Promise<object>)<br/>  - `text`(): 응답을 문자열로 변환 (Promise<string>)<br/>  - `blob`(): 응답을 Blob 객체로 변환 (Promise<Blob>)<br/><br/><br/>## 사용 예제<br/><br/>### 기본 GET 요청<br/><br/>```javascript<br/>fetch('https://jsonplaceholder.typicode.com/posts/1')<br/>  .then(response => {<br/>    if (!response.ok) {<br/>      throw new Error('네트워크 응답이 올바르지 않아요.');<br/>    }<br/>    return response.json();<br/>  })<br/>  .then(data => console.log(data))<br/>  .catch(error => console.error('오류 발생:', error));<br/>```<br/><br/><br/>### POST 요청 예제<br/><br/>```javascript<br/>fetch('https://api.example.com/user', {<br/>  method: 'POST',<br/>  headers: {<br/>    'Content-Type': 'application/json',<br/>  },<br/>  body: JSON.stringify({ name: 'John', age: 30 }),<br/>})<br/>  .then(response => {<br/>    if (!response.ok) {<br/>      throw new Error('요청이 실패했어요.');<br/>    }<br/>    return response.json();<br/>  })<br/>  .then(data => console.log('서버 응답:', data))<br/>  .catch(error => console.error('오류 발생:', error));<br/>```<br/><br/>### async/await 사용<br/><br/>```javascript<br/>async function fetchData() {<br/>  try {<br/>    const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');<br/><br/>    if (!response.ok) {<br/>      throw new Error('네트워크 응답이 올바르지 않아요.');<br/>    }<br/><br/>    const data = await response.json();<br/>    console.log(data);<br/>  } catch (error) {<br/>    console.error('오류 발생:', error);<br/>  }<br/>}<br/><br/>fetchData();<br/>``` |
| **설명 문서**      | 깊은 이해를 위한 설명 문서는 독자가 특정 기술이나 개념을 깊이 있게 이해할 수 있도록 돕는 것을 목표로 해요. 핵심은 배경과 맥락을 충분히 설명하고, 의사결정 과정을 명확히 공유하는 것이에요.<br/><br/>이 문서를 보면 독자는 단순한 사용법을 넘어 기술의 원리와 철학을 이해할 수 있어야 해요.<br/><br/>1. 배경 및 맥락을 제공해요<br/>기술이 등장한 이유와 해결하려는 문제를 먼저 설명해요.<br/>독자가 해당 기술을 왜 선택해야 하는지 납득할 수 있도록 설득력 있게 서술해요.<br/>2. 시각 자료를 적극적으로 활용해요<br/>복잡한 개념은 다이어그램, 흐름도, 표 등을 사용해 시각화해요.<br/>전체적인 구조, 데이터 흐름이나 컴포넌트 구조는 시각적으로 보여주면 더 직관적으로 이해할 수 있어요. | # React의 가상 DOM 작동 원리<br/><br/>React의 가상 DOM(Virtual DOM)은 UI 변경을 효율적으로 감지하고 최소한의 변경만 실제 DOM에 반영하는 방식을 통해 성능을 최적화하는 핵심 기술입니다. 이를 통해 불필요한 렌더링을 방지하고 빠른 UI 업데이트를 제공합니다.<br/><br/>## 가상 DOM이 등장한 배경<br/><br/>웹 애플리케이션이 복잡해지면서, 기존의 DOM 조작 방식에는 다음과 같은 문제가 발생했습니다.<br/><br/>- DOM 조작 비용이 크다: 직접적인 DOM 변경이 많아질수록 브라우저의 렌더링 성능이 저하됩니다.<br/>- 전체 페이지 리렌더링 문제: 특정 부분만 변경해도 전체 UI가 다시 그려지는 경우가 많습니다.<br/>- UI 성능 저하: 많은 DOM 업데이트가 발생하면 프레임 속도가 떨어지고 사용자 경험(UX)이 저하될 가능성이 높습니다.<br/><br/>React는 이러한 문제를 해결하기 위해 가상 DOM을 도입했습니다. 가상 DOM을 활용하면 변경 사항을 먼저 계산하고, 최소한의 연산으로 실제 DOM을 업데이트할 수 있습니다.<br/><br/>## 개념<br/><br/>가상 DOM(Virtual DOM)은 실제 DOM의 경량화된 JavaScript 객체 모델입니다. React는 UI 변경이 발생하면 이 가상 DOM을 업데이트한 후, 변경된 부분만 실제 DOM에 반영합니다.<br/><br/>이 방식의 장점은 다음과 같습니다:<br/>- 빠른 연산 가능: 가상 DOM은 메모리에서 동작하므로 계산 속도가 빠릅니다.<br/>- 효율적인 업데이트: 변경 사항을 비교하여 최소한의 DOM 업데이트만 수행합니다.<br/>- 예측 가능성 향상: 선언적 UI 모델을 유지하면서도 최적화된 성능을 제공합니다.<br/><br/>### 작동 방식<br/><br/>가상 DOM은 다음과 같은 과정을 거쳐 렌더링을 최적화해요.<br/><br/>1. UI 변경 감지: React는 컴포넌트의 상태(state)나 속성(props)이 변경되면 새로운 가상 DOM을 생성합니다.<br/>2. Diffing 알고리즘 적용: 이전 가상 DOM과 새로운 가상 DOM을 비교하여 변경된 요소를 찾습니다.<br/>3. 최소한의 변경만 반영: 변경된 부분만 실제 DOM에 적용하여 성능을 최적화합니다.<br/><br/>이 과정은 React의 핵심 알고리즘인 Reconciliation(조정 과정)을 기반으로 작동합니다.<br/><br/>## 시각적 다이어그램<br/><br/>다음 다이어그램은 가상 DOM의 작동 과정을 나타내요.<br/><br/>🖥️ UI 변경 감지<br/>  ┌─────────────────────────────────┐<br/>  │           UI 변경 감지            │<br/>  │   (컴포넌트의 상태/props 변경 감지)   │<br/>  └─────────────────────────────────┘<br/>                │<br/>                ▼<br/>⚙️ 가상 DOM 업데이트<br/>  ┌─────────────────────────────────┐<br/>  │       가상 DOM 생성 및 업데이트      │<br/>  └─────────────────────────────────┘<br/>                │<br/>                ▼<br/>🔍 Diffing 알고리즘 적용<br/>  ┌─────────────────────────────────┐<br/>  │       이전 가상 DOM과 비교하여       │<br/>  │           변경된 요소 도출          │<br/>  └─────────────────────────────────┘<br/>                │<br/>                ▼<br/>💻 최소 변경 반영 (실제 DOM)<br/>  ┌─────────────────────────────────┐<br/>  │     변경된 부분만 실제 DOM에 반영     │<br/>  └─────────────────────────────────┘<br/><br/>위 과정에서 가장 중요한 것은 Diffing 알고리즘입니다. React는 `key` 속성을 활용하여 변경된 노드를 빠르게 찾고, 효율적으로 업데이트할 수 있도록 설계되어 있습니다.<br/><br/>## 코드 예제<br/><br/>React의 가상 DOM을 활용하는 간단한 예제입니다.<br/><br/>```javascript<br/>import React, { useState } from 'react';<br/><br/>function Counter() {<br/>const [count, setCount] = useState(0);<br/><br/>  return (<br/>    <div><br/>    <p>현재 카운트: {count}</p><br/>    <button onClick={() => setCount(count + 1)}>증가</button><br/>    </div><br/>  );<br/>}<br/><br/>export default Counter;<br/>```<br/><br/>이 코드에서 `setCount`를 호출하면 React는 새로운 가상 DOM을 생성하고, 이전 상태와 비교하여 변경된 부분만 실제 DOM에 반영합니다.<br/><br/>가상 DOM은 Redux나 MobX 같은 상태 관리 라이브러리와 함께 사용하면 더욱 강력한 성능을 발휘할 수 있습니다. 이러한 라이브러리는 상태(state) 변경을 추적하고, 변경된 데이터를 기반으로 UI를 효율적으로 업데이트하는 역할을 합니다. |